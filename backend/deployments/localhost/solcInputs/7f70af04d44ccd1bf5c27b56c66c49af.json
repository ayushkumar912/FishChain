{
  "language": "Solidity",
  "sources": {
    "contracts/FisheriesManagement.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\ncontract FisheriesManagement {\n    address public government;\n    uint256 public nextBatchId = 1;\n\n    struct FishBatch {\n        uint256 id;\n        address fisher;\n        uint256 weight;\n        uint256 pricePerKg;\n        bool isSold;\n        bool inDispute;\n        bool sustainable;\n        uint256[] transferIds;\n    }\n\n    mapping(uint256 => FishBatch) public batches;\n\n    event FishLogged(\n        uint256 batchId,\n        address fisher,\n        uint256 weight,\n        uint256 pricePerKg\n    );\n    event SustainabilityUpdated(uint256 batchId, bool sustainable);\n    event DisputeRaised(uint256 batchId, string reason);\n\n    modifier onlyGovernment() {\n        require(\n            msg.sender == government,\n            \"Only government can call this function\"\n        );\n        _;\n    }\n\n    constructor() {\n        government = msg.sender;\n    }\n\n    function logCatch(uint256 weight, uint256 pricePerKg) public {\n        batches[nextBatchId] = FishBatch(\n            nextBatchId,\n            msg.sender,\n            weight,\n            pricePerKg,\n            false,\n            false,\n            false,\n            new uint256[](0)\n        );\n        emit FishLogged(nextBatchId, msg.sender, weight, pricePerKg);\n        nextBatchId++;\n    }\n\n    function updateSustainability(\n        uint256 batchId,\n        bool sustainable\n    ) public onlyGovernment {\n        batches[batchId].sustainable = sustainable;\n        emit SustainabilityUpdated(batchId, sustainable);\n    }\n\n    function raiseDispute(\n        uint256 batchId,\n        string memory reason\n    ) public onlyGovernment {\n        batches[batchId].inDispute = true;\n        emit DisputeRaised(batchId, reason);\n    }\n\n\n\n\nfunction getFishBatch(uint256 batchId)\n    external\n    view\n    returns (\n        uint256,\n        address,\n        uint256,\n        uint256,\n        bool,\n        bool,\n        bool,\n        uint256[] memory\n    )\n{\n    require(batches[batchId].id == batchId, \"Batch does not exist\");\n    FishBatch memory batch = batches[batchId];\n    return (\n        batch.id,\n        batch.fisher,\n        batch.weight,\n        batch.pricePerKg,\n        batch.isSold,\n        batch.inDispute,\n        batch.sustainable,\n        batch.transferIds\n    );\n}\n\n\n\n    function getBatchSustainability(\n        uint256 batchId\n    ) external view returns (bool) {\n        return batches[batchId].sustainable;\n    }\n\n    function getTransferIds(\n        uint256 batchId\n    ) external view returns (uint256[] memory) {\n        require(batches[batchId].id == batchId, \"Batch does not exist\");\n        return batches[batchId].transferIds;\n    }\n\n    function addTransferToBatch(uint256 batchId, uint256 transferId) external {\n        require(batches[batchId].id == batchId, \"Batch does not exist\");\n        batches[batchId].transferIds.push(transferId);\n    }\n\n    function updateweight(uint256 batchId, uint256 weight) external {\n        require(batches[batchId].id == batchId, \"Batch does not exist\");\n        batches[batchId].weight -= weight;\n    }\n}\n"
    },
    "contracts/FishMarketplace.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\nimport {FisheriesManagement} from \"./FisheriesManagement.sol\";\n\ncontract FishMarketplace {\n    FisheriesManagement fisheriesManagement;\n    address public pricingAdjustmentContract;\n\n    struct Listing {\n        uint256 listingId;\n        uint256 batchId;\n        address fisher;\n        uint256 totalWeight;\n        uint256 availableWeight;\n        uint256 pricePerKg;\n        bool isSoldOut;\n    }\n\n    mapping(uint256 => Listing) public listings;\n    uint256 public nextListingId = 1;\n\n    event FishListed(\n        uint256 listingId,\n        uint256 batchId,\n        uint256 weight,\n        uint256 pricePerKg\n    );\n    event FishBought(\n        uint256 listingId,\n        address buyer,\n        uint256 weight,\n        uint256 totalPrice\n    );\n    event PriceUpdated(uint256 listingId, uint256 newPricePerKg);\n\n    constructor(address fisheriesManagementAddress) {\n        fisheriesManagement = FisheriesManagement(fisheriesManagementAddress);\n    }\n\n    // modifier onlyPricingAdjustment() {\n    //     require(msg.sender == pricingAdjustmentContract, \"Unauthorized: Only the PricingAdjustment contract can adjust prices\");\n    //     _;\n    // }\n\n    function setPricingAdjustmentContract(\n        address _pricingAdjustmentContract\n    ) external {\n        require(\n            pricingAdjustmentContract == address(0),\n            \"Pricing adjustment contract already set\"\n        );\n        pricingAdjustmentContract = _pricingAdjustmentContract;\n    }\n\n    function listFish(\n        uint256 batchId,\n        uint256 weight,\n        uint256 pricePerKg\n    ) public {\n        require(\n            fisheriesManagement.getBatchSustainability(batchId),\n            \"Batch is not sustainable\"\n        );\n        fisheriesManagement.updateweight(batchId, weight);\n        listings[nextListingId] = Listing(\n            nextListingId,\n            batchId,\n            msg.sender,\n            weight,\n            weight,\n            pricePerKg,\n            false\n        );\n        emit FishListed(nextListingId, batchId, weight, pricePerKg);\n        nextListingId++;\n    }\n\n    function buyFish(uint256 listingId, uint256 weight) public payable {\n        Listing storage listing = listings[listingId];\n        require(!listing.isSoldOut, \"Listing is sold out\");\n        require(\n            weight <= listing.availableWeight,\n            \"Not enough weight available\"\n        );\n\n        uint256 totalPrice = weight * listing.pricePerKg;\n        require(msg.value >= totalPrice, \"Insufficient funds\");\n\n        listing.availableWeight -= weight;\n        if (listing.availableWeight == 0) {\n            listing.isSoldOut = true;\n        }\n        payable(listing.fisher).transfer(totalPrice);\n        emit FishBought(listingId, msg.sender, weight, totalPrice);\n    }\n\n    // New function to allow only authorized contract to adjust prices\n    function adjustListingPrice(\n        uint256 listingId,\n        uint256 newPricePerKg\n    ) external {\n        Listing storage listing = listings[listingId];\n        listing.pricePerKg = newPricePerKg;\n        emit PriceUpdated(listingId, newPricePerKg);\n    }\n\n    // New getter function to access listing details\n    function getListingDetails(\n        uint256 listingId\n    )\n        external\n        view\n        returns (uint256, uint256, address, uint256, uint256, uint256, bool)\n    {\n        Listing storage listing = listings[listingId];\n        return (\n            listing.listingId,\n            listing.batchId,\n            listing.fisher,\n            listing.totalWeight,\n            listing.availableWeight,\n            listing.pricePerKg,\n            listing.isSoldOut\n        );\n    }\n}\n"
    },
    "contracts/FishTransfer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\nimport {FisheriesManagement} from \"./FisheriesManagement.sol\";\n\ncontract FishTransfer {\n    FisheriesManagement public fisheriesManagement;\n    struct Transfer {\n        uint256 transferId;\n        uint256 batchId;\n        string stage; // e.g., \"Storage\", \"Transport\"\n        uint256 timestamp;\n    }\n\n    mapping(uint256 => Transfer) public transfers;\n    uint256 public nextTransferId = 1;\n\n    constructor(address fisheriesManagementAddress) {\n        fisheriesManagement = FisheriesManagement(fisheriesManagementAddress);\n    }\n\n    event TransferRecorded(\n        uint256 transferId,\n        uint256 batchId,\n        string stage,\n        uint256 timestamp\n    );\n\n    function recordTransfer(uint256 batchId, string memory stage) public {\n        // require(fisheriesManagement.batches(batchId).id == batchId, \"Batch does not exist\");\n\n        transfers[nextTransferId] = Transfer(\n            nextTransferId,\n            batchId,\n            stage,\n            block.timestamp\n        );\n        fisheriesManagement.addTransferToBatch(batchId, nextTransferId);\n        emit TransferRecorded(nextTransferId, batchId, stage, block.timestamp);\n        nextTransferId++;\n    }\n}\n"
    },
    "contracts/InspectorAuthorization.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\ncontract InspectorAuthorization {\n    address public government;\n    mapping(address => bool) public authorizedInspectors;\n\n    event InspectorAuthorized(address inspector);\n    event InspectorRevoked(address inspector);\n\n    modifier onlyGovernment() {\n        require(\n            msg.sender == government,\n            \"Only government can call this function\"\n        );\n        _;\n    }\n\n    constructor() {\n        government = msg.sender;\n    }\n\n    function authorizeInspector(address inspector) public onlyGovernment {\n        authorizedInspectors[inspector] = true;\n        emit InspectorAuthorized(inspector);\n    }\n\n    function revokeInspector(address inspector) public onlyGovernment {\n        authorizedInspectors[inspector] = false;\n        emit InspectorRevoked(inspector);\n    }\n}\n"
    },
    "contracts/PriceAdjustment.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\nimport \"./FishMarketplace.sol\";\n\ncontract PriceAdjustment {\n    mapping(uint256 => uint256) public sustainabilityMultiplier;\n    mapping(uint256 => uint256) public freshnessMultiplier;\n\n    event PriceAdjusted(uint256 batchId, uint256 newPricePerKg);\n    event DebugPriceChange(\n        uint256 listingId,\n        uint256 initialPrice,\n        uint256 adjustedPrice\n    );\n\n    FishMarketplace fishMarketplace;\n\n    constructor(address fishMarketplaceAddress) {\n        fishMarketplace = FishMarketplace(fishMarketplaceAddress);\n    }\n\n    function adjustPrice(\n        uint256 listingId,\n        uint256 sustainabilityFactor,\n        uint256 freshnessFactor\n    ) public {\n        (uint256 id, , , , , uint256 pricePerKg, ) = fishMarketplace\n            .getListingDetails(listingId);\n\n        require(id == listingId, \"Listing does not exist\");\n\n        uint256 initialPrice = pricePerKg;\n        uint256 adjustedPrice = initialPrice;\n\n        // Apply sustainability and freshness multipliers\n        if (sustainabilityFactor > 0) {\n            adjustedPrice = (adjustedPrice * sustainabilityFactor) / 100;\n        }\n        if (freshnessFactor > 0) {\n            adjustedPrice = (adjustedPrice * freshnessFactor) / 100;\n        }\n\n        // Update price in marketplace\n        fishMarketplace.adjustListingPrice(listingId, adjustedPrice);\n\n        emit DebugPriceChange(listingId, initialPrice, adjustedPrice);\n        emit PriceAdjusted(listingId, adjustedPrice);\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}